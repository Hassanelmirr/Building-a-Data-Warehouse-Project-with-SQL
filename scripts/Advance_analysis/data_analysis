
SELECT * FROM gold.fact_sales

SELECT 
	YEAR(order_date) AS order_date,
	SUM(total_sales) AS total_sales,
	COUNT(DISTINCT customer_id) AS total_customers,
	SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY YEAR(order_date)
ORDER BY YEAR(order_date) ASC

SELECT * FROM INFORMATION_SCHEMA.COLUMNS

-- Total sales by year
-- we detect time and the seasonality

SELECT FORMAT(fact.order_date, 'yyyy') AS year,
	SUM( fact.total_sales) AS total_sales,
	COUNT(fact.customer_id) AS total_customers,
	SUM(fact.quantity) AS quantity,
	SUM(dim.cost * fact.quantity) AS total_cost,
	AVG(dim.cost) AS total_cost,
	SUM(dim.cost * fact.quantity) / SUM(fact.quantity) as weighted_cost,
	SUM(total_sales - (dim.cost * fact.quantity)) AS profit,
	AVG(fact.price) AS unweighted_avg_price,
	AVG(fact.total_sales / NULLIF(fact.quantity,0)) AS weighted_avg_price
--	SUM(fact.total_sales) / SUM(fact.quantity) AS weighted_avg_price
FROM gold.fact_sales fact
LEFT JOIN gold.dim_product dim
ON fact.product_key = dim.product_number
WHERE order_date IS NOT NULL
GROUP BY FORMAT(fact.order_date, 'yyyy')
ORDER BY FORMAT(fact.order_date, 'yyyy') 

SELECT FORMAT(fact.order_date, 'yyyy-MMM') AS year,
	SUM( fact.total_sales) AS total_sales,
	COUNT(fact.customer_id) AS total_customers,
	SUM(fact.quantity) AS quantity,
	SUM(dim.cost * fact.quantity) AS total_cost,
	AVG(dim.cost) AS total_cost,
	SUM(dim.cost * fact.quantity) / SUM(fact.quantity) as weighted_cost,
	SUM(total_sales - (dim.cost * fact.quantity)) AS profit,
	AVG(fact.price) AS unweighted_avg_price,
	AVG(fact.total_sales / NULLIF(fact.quantity,0)) AS weighted_avg_price
--	SUM(fact.total_sales) / SUM(fact.quantity) AS weighted_avg_price
FROM gold.fact_sales fact
LEFT JOIN gold.dim_product dim
ON fact.product_key = dim.product_number
WHERE order_date IS NOT NULL
GROUP BY FORMAT(fact.order_date, 'yyyy-MMM')
ORDER BY FORMAT(fact.order_date, 'yyyy-MMM') 

SELECT DATETRUNC(month, fact.order_date) as order_date,
	SUM(dim.cost * fact.quantity) AS total_cost
FROM gold.fact_sales fact
LEFT JOIN gold.dim_product dim
ON fact.product_key = dim.product_number
WHERE order_date IS NOT NULL
GROUP BY DATETRUNC(month, fact.order_date)
ORDER BY DATETRUNC(month, fact.order_date)

select * from gold.fact_sales


-- cumulative analysis

-- Calculate the total sales over year
--- and the Running total sales by year 

SELECT * FROM INFORMATION_SCHEMA.COLUMNS

-- by month
SELECT 
	order_date,
	Total_sales,
	SUM(Total_sales) OVER( PARTITION BY DATETRUNC(year, order_date) ORDER BY order_date ) AS running_sales, -- Cumulative order with restarting from scratch each year !!
	avg_price,
	AVG(avg_price) OVER (PARTITION BY DATETRUNC(year, order_date) ORDER BY order_date) AS moving_avg_price
FROM(
SELECT 
	DATETRUNC(month, order_date) AS order_date,
	SUM(total_sales) AS Total_sales,
	AVG(price) as avg_price
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY DATETRUNC(month, order_date)
)t


-- by year
SELECT 
	order_date,
	Total_sales,
	SUM(Total_sales) OVER(ORDER BY order_date) AS running_sales, -- CUMULATIVE ADITION
	AVG(avg_price) OVER(ORDER BY order_date) AS moving_avg_price
FROM(
SELECT 
	DATETRUNC(YEAR, order_date) AS order_date,
	SUM(total_sales) AS Total_sales,
	AVG(price) AS avg_price
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY DATETRUNC(YEAR, order_date)
)t

-- yearly perfomance of products : 
-- comparing each [product's sales] to both : 1- its [average sales performance]
--											  2- the [previous year's sales]

SELECT * FROM INFORMATION_SCHEMA.COLUMNS

WITH yearly_product_sales AS(
SELECT 
	YEAR(f.order_date) AS order_date,
	d.product_name AS product_name,
	SUM(f.total_sales) AS current_sales
FROM gold.fact_sales f
LEFT JOIN gold.dim_product d
ON f.product_key = d.product_number
WHERE f.order_date IS NOT NULL
GROUP BY YEAR(f.order_date), d.product_name
)
SELECT 
order_date,
product_name,
current_sales,
AVG(current_sales) OVER(PARTITION BY product_name) AS avg_sales,
current_sales - AVG(current_sales) OVER(PARTITION BY product_name) AS dif_avg,
CASE 
	WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) < 0 THEN 'Bellow Avg'
	WHEN current_sales - AVG(current_sales) OVER(PARTITION BY product_name) > 0 THEN 'Above Avg'
	ELSE 'On Avg'
END avg_change,
LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_date) AS sales_change,
current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_date) AS Delta,
CASE 
	WHEN current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_date) < 0 THEN 'Decreasing'
	WHEN current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_date) > 0 THEN 'Increasing'
	ELSE 'No change'
END change_satatus,
CAST((current_sales - LAG(current_sales)  OVER(PARTITION BY product_name ORDER BY order_date)) AS FLOAT)  / CAST(ABS(current_sales - LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_date )) AS FLOAT) AS Growth_rate
FROM yearly_product_sales
ORDER BY product_name, order_date



--- which categories contribute the most to overall sales? 

SELECT * FROM INFORMATION_SCHEMA.COLUMNS

WITH over_all_sales AS(
SELECT 
	d.category,
	SUM(f.total_sales) as total_sales
FROM gold.fact_sales f
LEFT JOIN gold.dim_product d
ON f.product_key = d.product_number
GROUP BY category)

SELECT category,
	total_sales,
	SUM(total_sales) OVER() AS over_all_sales,
	CONCAT(ROUND((CAST(total_sales AS FLOAT) / SUM(total_sales) OVER()) * 100 ,2),'%')  AS sales_proportion
FROM over_all_sales
ORDER BY total_sales DESC

/* Segment products into cost ranges and 
count how many products fall into each segment */

SELECT * FROM gold.dim_product

WITH products_by_cost_range AS(
SELECT 
	cost,
	CASE 
	WHEN cost < 100 THEN 'bellow 100'
	WHEN cost BETWEEN 100 AND 500 THEN '100-500'
	WHEN cost BETWEEN 500 AND 1000 THEN '500 - 1000'
	WHEN cost BETWEEN 1000 AND 2000 THEN '1000 - 2000'
	ELSE 'above 2000'
	END cost_range,
	product_name,
	product_number
FROM gold.dim_product)
SELECT cost_range,
	COUNT(product_name) as nb_of_products
FROM products_by_cost_range
GROUP BY cost_range
ORDER BY nb_of_products DESC


/* Group customers into three segments based on their spending behavior: 
	- VIP : customers with at least 12 months of history and spending more than 5000 euros.
	- Regular: customers with at least 12 months of history but spending 5000 euros or less.
	- New : Customers with a lifespan less than 12 months
AND find the number of customers by each group.
*/

SELECT * FROM gold.dim_customers
SELECT * FROM gold.dim_product
SELECT * FROM gold.fact_sales

With customer_behavior AS(
SELECT 
	d.customer_key ,
	SUM(f.total_sales) AS total_spending,         -- CTE BODY
	month(MIN(f.order_date)) AS first_order,
	month(MAX(f.order_date)) AS last_order,
	DATEDIFF(month, MIN(f.order_date), MAX(f.order_date)) AS lifespan
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers d
ON f.customer_id = d.customer_id
GROUP BY customer_key)

SELECT 
	customer_seg ,
	COUNT(customer_key) AS total_customers    -- OUTER QUery / CTE MAIN QUERY 
	

FROM(
SELECT 
	customer_key,
	total_spending,
	CASE WHEN 
		lifespan >= 12 AND total_spending > 5000 THEN 'VIP'
		WHEN 
		lifespan >= 12 AND total_spending <= 5000 THEN 'Regular'   -- subquery : where I can use group by and order by 
		ELSE 'NEW'
	END customer_seg
FROM customer_behavior)T
GROUP BY customer_seg
ORDER BY total_customers ASC



